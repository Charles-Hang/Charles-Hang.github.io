<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>[学习笔记]《你不知道的JavaScript（上）》核心知识点 | 察 尔丝</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="学习笔记," />
  

  <meta name="description" content="第一部分 作用域和闭包第4章 提升编译器会在解释JavaScript代码之前进行编译，包括变量和函数在内的所有声明都会在任何代码被执行前首先处理，即把它们在代码中出现的位置“移动”到最上面，这个过程就是提升。示例：1234567891011121314151617181920212223242526console.log(a);var a = a;==&amp;gt;var a;console.log(a">
<meta property="og:type" content="article">
<meta property="og:title" content="[学习笔记]《你不知道的JavaScript（上）》核心知识点">
<meta property="og:url" content="http://charles-hang.github.io/2017/03/29/sn-js-youDontKnowJs1/index.html">
<meta property="og:site_name" content="察 尔丝">
<meta property="og:description" content="第一部分 作用域和闭包第4章 提升编译器会在解释JavaScript代码之前进行编译，包括变量和函数在内的所有声明都会在任何代码被执行前首先处理，即把它们在代码中出现的位置“移动”到最上面，这个过程就是提升。示例：1234567891011121314151617181920212223242526console.log(a);var a = a;==&amp;gt;var a;console.log(a">
<meta property="og:updated_time" content="2017-03-29T12:56:11.571Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[学习笔记]《你不知道的JavaScript（上）》核心知识点">
<meta name="twitter:description" content="第一部分 作用域和闭包第4章 提升编译器会在解释JavaScript代码之前进行编译，包括变量和函数在内的所有声明都会在任何代码被执行前首先处理，即把它们在代码中出现的位置“移动”到最上面，这个过程就是提升。示例：1234567891011121314151617181920212223242526console.log(a);var a = a;==&amp;gt;var a;console.log(a">

  

  
    <link rel="icon" href="/images/favicon.ico">
  

  <link href="/css/styles.css?v=028c63b1" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?6bba9001e0ba66f5cfd0fdbd66ba39b2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第一部分-作用域和闭包"><span class="toc-text">第一部分 作用域和闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#第4章-提升"><span class="toc-text">第4章 提升</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#提示"><span class="toc-text">提示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第5章-作用域闭包"><span class="toc-text">第5章 作用域闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#模块"><span class="toc-text">模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录A-动态作用域"><span class="toc-text">附录A 动态作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二部分-this和对象原型"><span class="toc-text">第二部分 this和对象原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this到底是什么"><span class="toc-text">this到底是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this全面解析"><span class="toc-text">this全面解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调用位置"><span class="toc-text">调用位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定规则"><span class="toc-text">绑定规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#默认绑定"><span class="toc-text">默认绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#隐式绑定"><span class="toc-text">隐式绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#显示绑定"><span class="toc-text">显示绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new绑定"><span class="toc-text">new绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优先级"><span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一种情况"><span class="toc-text">一种情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第3章-对象"><span class="toc-text">第3章 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类型"><span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内容"><span class="toc-text">内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#可计算属性名"><span class="toc-text">可计算属性名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性描述符"><span class="toc-text">属性描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不变性"><span class="toc-text">不变性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Getter和Setter（访问描述符）"><span class="toc-text">Getter和Setter（访问描述符）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第4章-混合对象“类”"><span class="toc-text">第4章 混合对象“类”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#混入"><span class="toc-text">混入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#显示混入"><span class="toc-text">显示混入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#寄生继承"><span class="toc-text">寄生继承</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#隐式混入"><span class="toc-text">隐式混入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第5章-原型"><span class="toc-text">第5章 原型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性设置和屏蔽"><span class="toc-text">属性设置和屏蔽</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#“类”"><span class="toc-text">“类”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#“构造函数”"><span class="toc-text">“构造函数”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（原型）继承"><span class="toc-text">（原型）继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#检查“类”关系"><span class="toc-text">检查“类”关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象关联"><span class="toc-text">对象关联</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第6章-行为委托"><span class="toc-text">第6章 行为委托</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#委托理论"><span class="toc-text">委托理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#比较思维模型"><span class="toc-text">比较思维模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类与对象"><span class="toc-text">类与对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更好地语法"><span class="toc-text">更好地语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录A-ES6中的Class"><span class="toc-text">附录A ES6中的Class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#class陷阱"><span class="toc-text">class陷阱</span></a></li></ol></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-sn-js-youDontKnowJs1" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">[学习笔记]《你不知道的JavaScript（上）》核心知识点</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.03.29</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Charles Hang</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/js/">js</a>
  </span>



      

    </div>
  </header>

  <div class="article-content">
    
      <h1 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h1><h2 id="第4章-提升"><a href="#第4章-提升" class="headerlink" title="第4章 提升"></a>第4章 提升</h2><p>编译器会在解释JavaScript代码之前进行编译，包括变量和函数在内的所有声明都会在任何代码被执行前首先处理，即把它们在代码中出现的位置“移动”到最上面，这个过程就是提升。示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="keyword">var</span> a = a;</div><div class="line"></div><div class="line">==&gt;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></div><div class="line">a = a; </div><div class="line"></div><div class="line">====</div><div class="line"></div><div class="line">foo();</div><div class="line">bar();</div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">==&gt;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line">foo(); <span class="comment">// TypeError</span></div><div class="line">bar(); <span class="comment">// ReferenceError</span></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> bar = ...self...</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量。示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"><span class="keyword">var</span> foo;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">==&gt;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">foo(); <span class="comment">// 1</span></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。要注意避免重复声明，特别是当普通的var声明和函数声明混合在一起的时候，会有很多危险！</p>
<h2 id="第5章-作用域闭包"><a href="#第5章-作用域闭包" class="headerlink" title="第5章 作用域闭包"></a>第5章 作用域闭包</h2><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> baz = foo();</div><div class="line">baz(); <span class="comment">// 2 ---闭包的效果</span></div></pre></td></tr></table></figure></p>
<p><code>foo()</code>执行后，通常整个内部作用域都被销毁，但由于<code>bar()</code>本身在使用，就阻止了回收，它拥有<code>foo()</code>内部作用域的闭包，使得该作用域能够一直存活，以供<code>bar()</code>在之后任何时间进行引用。<code>bar()</code>一直持有对该作用域的引用，这个引用就叫作闭包。<br>本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、web workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！<br>立即执行函数创造的新的作用域，也就是创造了闭包，只是没有在其他的作用域使用。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>闭包的一个强大应用就是模块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> something = <span class="string">"cool"</span>;</div><div class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(something);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(another.join(<span class="string">"!"</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>&#123;</div><div class="line">        <span class="attr">doSomething</span>: doSomething,</div><div class="line">        <span class="attr">doAnother</span>: doAnoter</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo = CoolModule();</div><div class="line">foo.doSomething(); <span class="comment">// cool</span></div><div class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></div></pre></td></tr></table></figure></p>
<p>CoolModule()只是一个函数，必须要通过调用它来创建一个模块实例。模块模式需要具备两个必要条件：</p>
<ol>
<li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ol>
<p>一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。<br>es6已经提供了一个稳定的模块API供我们使用。</p>
<h2 id="附录A-动态作用域"><a href="#附录A-动态作用域" class="headerlink" title="附录A 动态作用域"></a>附录A 动态作用域</h2><p>JavaScript中的作用域就是词法作用域，词法作用域最重要的特征是它的定义过程发生在代码的书写阶段。而动态作用域是一个在运行时被动态确定的形式，它们不关心函数和作用域时如何声明以及在何处声明的，只关心它们从何处调用。这里之所以要提及动态作用域，是因为JavaScript的this机制某种程度上很像动态作用域，它是在运行时动态确定的，this关注函数如何调用。</p>
<h1 id="第二部分-this和对象原型"><a href="#第二部分-this和对象原型" class="headerlink" title="第二部分 this和对象原型"></a>第二部分 this和对象原型</h1><h3 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h3><p>this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。当一个函数调用时，会创建一个执行上下文，这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this就是这个上下文的其中一个属性。</p>
<h2 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h2><h3 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h3><p>找到调用位置，最重要的是要分析调用栈（就是为了达到当前执行位置所调用的所有函数）。调用位置就是在当前正在执行的函数的前一个调用中。示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 当前调用栈是： baz</span></div><div class="line">    <span class="comment">// 因此，当前调用位置是全局作用域</span></div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"baz"</span>);</div><div class="line">    bar(); <span class="comment">// &lt;-- bar的调用位置</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 当前调用栈是baz -&gt; bar</span></div><div class="line">    <span class="comment">// 因此，当前调用位置在baz中</span></div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</div><div class="line">    foo(); <span class="comment">// &lt;-- foo的调用位置</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 当前调用栈是baz -&gt; bar -&gt; foo</span></div><div class="line">    <span class="comment">// 因此，当前调用位置在bar中</span></div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</div><div class="line">&#125;</div><div class="line">baz(); <span class="comment">// &lt;-- baz的调用位置</span></div></pre></td></tr></table></figure></p>
<h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>当函数不带任何修饰的进行调用时，即独立函数调用，使用默认绑定。默认绑定下，如果函数使用严格模式，this会绑定到undefined，否则指向全局对象。</p>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>这条规则是要考虑调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">foo</span>: foo</div><div class="line">&#125;;</div><div class="line">obj.foo(); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>把函数当作参数赋值，隐式绑定的函数会丢失绑定对象，会应用默认绑定规则。示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">foo</span>: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名！</span></div><div class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a是全局对象的属性</span></div><div class="line">bar(); <span class="comment">// "oops, global"</span></div></pre></td></tr></table></figure></p>
<p><code>bar()</code>调用的是<code>foo()</code>函数本身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="comment">// fn 其实引用的是foo</span></div><div class="line"></div><div class="line">    fn(); <span class="comment">// &lt;-- 调用位置</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">foo</span>: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a是全局对象的属性</span></div><div class="line">doFoo(obj.foo); <span class="comment">// "oops, global"</span></div></pre></td></tr></table></figure></p>
<p>参数传递其实就是一种隐式赋值，结果和上一个例子一样。</p>
<h4 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h4><p>使用Function.prototype.call Function.prototype.apply Function.prototype.bind 方法可以强制将this绑定到某一上下文上。</p>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>JavaScript虽然也有一个new操作符，但它与其他面向类的语言安全不同，并不存在所谓的构造函数，只有对于函数的构造调用。使用new来调用函数，会自动执行下面的操作：</p>
<ol>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个新对象会被执行【【原型】】连接。</li>
<li>这个新对象会绑定到函数调用的this。</li>
<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<p>new是最后一种可以影响函数调用时this绑定行为的方法，称之为new绑定。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<h3 id="一种情况"><a href="#一种情况" class="headerlink" title="一种情况"></a>一种情况</h3><p>把null或者undefined作为this的绑定对象传入call、apply或bind时，应用的是默认绑定规则。这时为了不对全局对象产生影响，可以用Object.create(null)创建一个空对象将this绑定在这个空对象中：<code>foo.apply(Object.create(null),[1,2,3])</code>。</p>
<h2 id="第3章-对象"><a href="#第3章-对象" class="headerlink" title="第3章 对象"></a>第3章 对象</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>举个例子来说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> strPrimitive = <span class="string">"I am a string"</span>;</div><div class="line"><span class="keyword">typeof</span> strPrimitive; <span class="comment">// "string"</span></div><div class="line">strPrimitive <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> strObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"I am a string"</span>);</div><div class="line"><span class="keyword">typeof</span> strObject; <span class="comment">// "object"</span></div><div class="line">strObject <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(strObject); <span class="comment">// [object String]</span></div></pre></td></tr></table></figure></p>
<p>上面strPrimitive只是一个string基本类型，不可变的值，而strObject是一个String对象。之所以可以直接对string基本类型使用String对象的方法是因为JavaScript会在必要时自动把字符串字面量转换成一个String对象，数值字面量也是如此，因此定义时推荐用字面量的形式，简洁方便。</p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>在对象中，属性名永远都是字符串。如果你是用string（字面量）以外的其他值作为属性名，那它也会首先被转换成字符串，即使数字也不例外，虽然在数组下标中使用的是数字，但在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数值中数字的用法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = &#123; &#125;;</div><div class="line">myObject[<span class="literal">true</span>] = <span class="string">"foo"</span>;</div><div class="line">myObject[<span class="number">3</span>] = <span class="string">"bar"</span>;</div><div class="line">myObject[myObject] = <span class="string">"baz"</span>;</div><div class="line"></div><div class="line">myObject[<span class="string">"true"</span>]; <span class="comment">// "foo"</span></div><div class="line">myObject[<span class="string">"3"</span>]; <span class="comment">// "bar"</span></div><div class="line">myObject[<span class="string">"[object Object]"</span>]; <span class="comment">// "baz"</span></div></pre></td></tr></table></figure></p>
<h4 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h4><p>ES6 增加了可计算属性名：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> prefix = <span class="string">"foo"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">[prefix + <span class="string">"bar"</span>]:<span class="string">"hello"</span>,</div><div class="line">[prefix + <span class="string">"baz"</span>]: <span class="string">"world"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject[<span class="string">"foobar"</span>]; <span class="comment">// hello</span></div><div class="line">myObject[<span class="string">"foobaz"</span>]; <span class="comment">// world</span></div></pre></td></tr></table></figure></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [ <span class="string">"foo"</span>, <span class="number">42</span>, <span class="string">"bar"</span> ];</div><div class="line">myArray.baz = <span class="string">"baz"</span>;</div><div class="line">myArray.length; <span class="comment">// 3</span></div><div class="line">myArray.baz; <span class="comment">// "baz"</span></div></pre></td></tr></table></figure></p>
<p>可以看到虽然添加了命名属性，数组的length值并未发生变化。完全可以把数组当作一个普通的键/值对象来使用，但这不是一个好选择。<br>当试图给数组添加一个数字字符串的属性名时，它会变成一个数值下标，注意与对象区别：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [ <span class="string">"foo"</span>, <span class="number">42</span>, <span class="string">"bar"</span> ];</div><div class="line">myArray[<span class="string">"3"</span>] = <span class="string">"baz"</span>;</div><div class="line">myArray.length; <span class="comment">// 4</span></div><div class="line">myArray[<span class="number">3</span>]; <span class="comment">// "baz"</span></div></pre></td></tr></table></figure></p>
<h4 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h4><p>直接上代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">    <span class="attr">a</span>:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor( myObject, <span class="string">"a"</span> );</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">// value: 2,</span></div><div class="line"><span class="comment">// writable: true,</span></div><div class="line"><span class="comment">// enumerable: true,</span></div><div class="line"><span class="comment">// configurable: true</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">&#125;);</div><div class="line">myObject.a; <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>writable和enumerable不用说，configurable为false时，就不能用<code>defineProperty()</code>方法来修改属性描述符，也不能用delete语句删除这个属性。这里有个小例外：即便属性是不可配置的，我们还是可以把是否可写状态由true改为false，不过无法由false改为true。</p>
<h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><ol>
<li><p>对象常量<br>结合<code>writable:false</code>和<code>configurable:false</code>就可以创建一个真正的常量属性（不可修改、重定义或删除）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"FAVORITE_NUMBER"</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">42</span>,</div><div class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>禁止扩展<br>可以使用<code>Object.preventExtensions()</code>来禁止一个对象添加新属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">    <span class="attr">a</span>:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.preventExtensions( myObject );</div><div class="line">myObject.b = <span class="number">3</span>;</div><div class="line">myObject.b; <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>严格模式下会抛出错误。</p>
<ol>
<li>密封<br><code>Object.seal()</code>会创建一个“密封”对象，相当于<code>Object.preventExtensions() + configurable:false</code></li>
<li>冻结<br><code>Object.freeze</code>会创建一个冻结对象，相当于<code>Object.seal() + writable:false</code>。冻结是可以用在一个对象上的级别最高的不可变性。<h4 id="Getter和Setter（访问描述符）"><a href="#Getter和Setter（访问描述符）" class="headerlink" title="Getter和Setter（访问描述符）"></a>Getter和Setter（访问描述符）</h4>直接上代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">    <span class="comment">// 给a 定义一个getter</span></div><div class="line">    get a() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(</div><div class="line">    myObject, <span class="comment">// 目标对象</span></div><div class="line">    <span class="string">"b"</span>, <span class="comment">// 属性名</span></div><div class="line">    &#123; <span class="comment">// 描述符</span></div><div class="line">        <span class="comment">// 给b 设置一个getter</span></div><div class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span> &#125;,</div><div class="line">        <span class="comment">// 确保b 会出现在对象的属性列表中</span></div><div class="line">        enumerable: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">);</div><div class="line">myObject.a; <span class="comment">// 2</span></div><div class="line">myObject.b; <span class="comment">// 4</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>setter同理，当只定义一个时，会忽略另一个操作，通常getter和setter是成对出现的，否则可能才产生意料之外的行为。</p>
<h2 id="第4章-混合对象“类”"><a href="#第4章-混合对象“类”" class="headerlink" title="第4章 混合对象“类”"></a>第4章 混合对象“类”</h2><h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><h4 id="显示混入"><a href="#显示混入" class="headerlink" title="显示混入"></a>显示混入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 非常简单的mixin()例子：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">sourceObj, targetObj</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> sourceObj) &#123;</div><div class="line">        <span class="comment">// 只会在不存在的情况下复制 但也只是复制引用</span></div><div class="line">        <span class="keyword">if</span>(!(key <span class="keyword">in</span> targetObj)) &#123;</div><div class="line">            targetObj[key] = sourceObj[key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> targetObj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Vehicle = &#123;</div><div class="line">    <span class="attr">engines</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">ignition</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Turning on my engine."</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">drive</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.ignition();</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"steering and moving forward!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> Car = mixin(Vehicle, &#123;</div><div class="line">    <span class="attr">wheels</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">drive</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        Vehicle.drive.call(<span class="keyword">this</span>);  <span class="comment">// 显式多态</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Rolling on all "</span> + <span class="keyword">this</span>.wheels + <span class="string">" wheels!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面看似是很棒的机制，实际上并不能带来太多好处，要注意只在能提高代码可读性的前提下使用显示混入，避免使用增加代码理解难度或者让对象关系更加复杂的模式。</p>
<h5 id="寄生继承"><a href="#寄生继承" class="headerlink" title="寄生继承"></a>寄生继承</h5><p>显示混入模式的一种变体，它既是显式的又是隐式的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//"传统的JavaScript类"Vehicle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vehicle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.engines = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">Vehicle.prototype.ignition = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Turning on my engine."</span>);</div><div class="line">&#125;;</div><div class="line">vehicle.prototype.drive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.ignition();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Steering and moving forward!"</span>);</div><div class="line">&#125;;</div><div class="line"><span class="comment">//"寄生类"Car</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//首先，car是一个Vehicle</span></div><div class="line">    <span class="keyword">var</span> car = <span class="keyword">new</span> Vehicle();</div><div class="line">    <span class="comment">//接着对car进行定制</span></div><div class="line">    car.wheels = <span class="number">4</span>;</div><div class="line">    <span class="comment">//保存到Vehicle::drive()的特殊引用</span></div><div class="line">    <span class="keyword">var</span> vehDrive = car.drive;</div><div class="line">    <span class="comment">//重写Vehicle::drive()</span></div><div class="line">    car.drive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        vehDrive.call(<span class="keyword">this</span>);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Rolling on all "</span> + <span class="keyword">this</span>.wheels + <span class="string">" wheels!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> car;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> myCar = <span class="keyword">new</span> Car();</div><div class="line">myCar.drive();</div></pre></td></tr></table></figure></p>
<h4 id="隐式混入"><a href="#隐式混入" class="headerlink" title="隐式混入"></a>隐式混入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Something = &#123;</div><div class="line">    <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.greeting = <span class="string">"Hello World"</span>;</div><div class="line">        <span class="keyword">this</span>.count = <span class="keyword">this</span>.count ? <span class="keyword">this</span>.count + <span class="number">1</span> : <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Something.cool();</div><div class="line">Something.greeting; <span class="comment">// "Hello World"</span></div><div class="line">Something.count; <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> Another = &#123;</div><div class="line">    <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 隐式把Something 混入Another</span></div><div class="line">        Something.cool.call( <span class="keyword">this</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Another.cool();</div><div class="line">Another.greeting; <span class="comment">// "Hello World"</span></div><div class="line">Another.count; <span class="comment">// 1 （count 不是共享状态）</span></div></pre></td></tr></table></figure>
<p>这类技术虽利用了this的重新绑定功能，但不够灵活，通常来说，应尽量避免使用这样的结构，以保证代码的整洁和可维护性。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>混入模式虽可用来模拟类的复制行为，但通常会产生丑陋并且脆弱的语法，这会让代码更加难懂并且难以维护。况且JavaScript并不会像类一样创建对象的副本，只能复制引用。</p>
<h2 id="第5章-原型"><a href="#第5章-原型" class="headerlink" title="第5章 原型"></a>第5章 原型</h2><h4 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h4><p>分析下面这个给一个对象设置属性的过程：<br><code>myObject.foo = &quot;bar&quot;;</code><br>如果myObject中包含foo的普通数据访问属性，这条赋值语句只会修改已有的属性值。<br>如果myObject中不存在foo，原型链上也找不到foo，foo就会被直接添加到myObject上。<br>如果foo既出现在myObject中也出现在myObject的原型链中，就会发生屏蔽。myObject 中包含的foo 属性会屏蔽原型链上层的所有foo 属性。<br>但是如果foo不直接存在与myObject中而是存在原型链上时，<code>myObject.foo = &quot;bar&quot;;</code>会出现三种情况：</p>
<ol>
<li>如果在原型链上存在名为foo 的普通数据访问属性，并且没有被标记为只读（writable:false），那就会直接在myObject 中添加一个名为foo 的新属性，它是屏蔽属性。</li>
<li>如果在原型链上存在foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li>
<li>如果在原型链上存在foo 并且它是一个setter，那就一定会调用这个setter。foo不会被添加到（或者说屏蔽于）myObject，也不会重新定义foo 这个setter。</li>
</ol>
<p>只有第一种才会触发屏蔽，如果是第二、第三种就不能使用<code>=</code>来赋值了，就要使用<code>Object.defineProperty()</code>来向myObject添加foo.<br>一些情况会产生隐式屏蔽：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> anotherObject = &#123;</div><div class="line">    <span class="attr">a</span>:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</div><div class="line">anotherObject.a; <span class="comment">// 2</span></div><div class="line">myObject.a; <span class="comment">// 2</span></div><div class="line">anotherObject.hasOwnProperty( <span class="string">"a"</span> ); <span class="comment">// true</span></div><div class="line">myObject.hasOwnProperty( <span class="string">"a"</span> ); <span class="comment">// false</span></div><div class="line"></div><div class="line">myObject.a++; <span class="comment">// 隐式屏蔽！</span></div><div class="line"></div><div class="line">anotherObject.a; <span class="comment">// 2</span></div><div class="line">myObject.a; <span class="comment">// 3</span></div><div class="line"></div><div class="line">myObject.hasOwnProperty( <span class="string">"a"</span> ); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p><code>myObject.a++;</code>相当于<code>myObject.a = myObject.a + 1;</code>这样给myObject新建了屏蔽属性a！</p>
<h3 id="“类”"><a href="#“类”" class="headerlink" title="“类”"></a>“类”</h3><h4 id="“构造函数”"><a href="#“构造函数”" class="headerlink" title="“构造函数”"></a>“构造函数”</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line">Foo.prototype.constructor === Foo; <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</div><div class="line">a.constructor === Foo; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>Foo.prototype默认有一个共有并且不可枚举的属性<code>.constructor</code>,这个属性引用的是对象关联的函数（本例是Foo）。a本身并没有<code>.constructor</code>属性，只是委托给了Foo.prototype，这和“构造”毫无关系。对于<code>.constructor</code>的错误理解很容易对你自己产生误导。例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* .. */</span> &#125;</div><div class="line">Foo.prototype = &#123; <span class="comment">/* .. */</span> &#125;; <span class="comment">// 创建一个新原型对象</span></div><div class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Foo();</div><div class="line">a1.constructor === Foo; <span class="comment">// false!</span></div><div class="line">a1.constructor === <span class="built_in">Object</span>; <span class="comment">// true!</span></div></pre></td></tr></table></figure></p>
<p>Object()并没有“构造”a1，看起来应该是Foo()“构造”了它，这次的结果是因为Foo.prototype也没有<code>.constructor</code>属性，继续向上委托到了Object.prototype。<br>当然，此时可以给Foo.prototype通过Object.defineProperty添加一个不可枚举的<code>.constructor</code>属性来达到最开始的效果。</p>
<h3 id="（原型）继承"><a href="#（原型）继承" class="headerlink" title="（原型）继承"></a>（原型）继承</h3><p>典型的“原型风格”：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Foo.prototype.myName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name,label</span>) </span>&#123;</div><div class="line">    Foo.call( <span class="keyword">this</span>, name );</div><div class="line">    <span class="keyword">this</span>.label = label;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 我们创建了一个新的Bar.prototype 对象并关联到Foo.prototype</span></div><div class="line">Bar.prototype = <span class="built_in">Object</span>.create( Foo.prototype );</div><div class="line"><span class="comment">// 注意！现在没有Bar.prototype.constructor 了</span></div><div class="line"><span class="comment">// 如果你需要这个属性的话可能需要手动修复一下它</span></div><div class="line"></div><div class="line">Bar.prototype.myLabel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.label;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar( <span class="string">"a"</span>, <span class="string">"obj a"</span> );</div><div class="line">a.myName(); <span class="comment">// "a"</span></div><div class="line">a.myLabel(); <span class="comment">// "obj a"</span></div></pre></td></tr></table></figure></p>
<p>上面代码的核心部分就是语句<code>Bar.prototype = Object.create(Foo.prototype)</code>。调用<code>Object.create()</code>会凭空创建一个“新”对象并把新对象内部的原型关联到你指定的对象（本例中是Foo.prototype）。ES6新增了一种方法：<code>Object.setPrototypeOf( Bar.prototype, Foo.prototype );</code>也可以实现。</p>
<h4 id="检查“类”关系"><a href="#检查“类”关系" class="headerlink" title="检查“类”关系"></a>检查“类”关系</h4><p>检查一个实例（JavaScript中的对象）的继承祖先（JavaScript中的委托关联）通常被称为内省（或者反射）。<br><code>b.isPrototypeOf( c );</code>b是否出现在c的原型链中。也可以直接获取一个对象的原型链<code>Object.getPrototypeOf( a );</code>。<code>.__proto__</code>引用了对象的原型对象，在ES6中也成为了标准。</p>
<h3 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> anotherObject = &#123;</div><div class="line">    <span class="attr">a</span>:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject, &#123;</div><div class="line">    <span class="attr">b</span>: &#123;</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">value</span>: <span class="number">3</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">c</span>: &#123;</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">value</span>: <span class="number">4</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myObject.hasOwnProperty( <span class="string">"a"</span> ); <span class="comment">// false</span></div><div class="line">myObject.hasOwnProperty( <span class="string">"b"</span> ); <span class="comment">// true</span></div><div class="line">myObject.hasOwnProperty( <span class="string">"c"</span> ); <span class="comment">// true</span></div><div class="line"></div><div class="line">myObject.a; <span class="comment">// 2</span></div><div class="line">myObject.b; <span class="comment">// 3</span></div><div class="line">myObject.c; <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<p>为了使代码更具可读性，更易维护，推荐使用内部委托：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> anotherObject = &#123;</div><div class="line">    <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"cool!"</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</div><div class="line">myObject.doCool = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.cool(); <span class="comment">// 内部委托！</span></div><div class="line">&#125;;</div><div class="line">myObject.doCool(); <span class="comment">// "cool!"</span></div></pre></td></tr></table></figure></p>
<h2 id="第6章-行为委托"><a href="#第6章-行为委托" class="headerlink" title="第6章 行为委托"></a>第6章 行为委托</h2><h4 id="委托理论"><a href="#委托理论" class="headerlink" title="委托理论"></a>委托理论</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Task = &#123;</div><div class="line">    <span class="attr">setID</span>: <span class="function"><span class="keyword">function</span>(<span class="params">ID</span>) </span>&#123; <span class="keyword">this</span>.id = ID; &#125;,</div><div class="line">    <span class="attr">outputID</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="keyword">this</span>.id ); &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 让XYZ 委托Task</span></div><div class="line">XYZ = <span class="built_in">Object</span>.create( Task );</div><div class="line">XYZ.prepareTask = <span class="function"><span class="keyword">function</span>(<span class="params">ID,Label</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setID( ID );</div><div class="line">    <span class="keyword">this</span>.label = Label;</div><div class="line">&#125;;</div><div class="line">XYZ.outputTaskDetails = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.outputID();</div><div class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.label );</div><div class="line">&#125;;</div><div class="line"><span class="comment">// ABC = Object.create( Task );</span></div><div class="line"><span class="comment">// ABC ... = ...</span></div></pre></td></tr></table></figure>
<p>通常来说，在原型委托中最好把状态保存在委托者（XYZ、ABC）而不是委托目标（Task）上。尽量避免在原型链的不同级别中使用相同的命名，用以消除引用歧义。委托行为意味着某些对象（XYZ）在找不到属性或者方法引用时会把这个请求委托给另一个对象（Task）。要禁止互相委托。</p>
<h4 id="比较思维模型"><a href="#比较思维模型" class="headerlink" title="比较思维模型"></a>比较思维模型</h4><p>典型的（“原型”）面向对象风格：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">who</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.me = who;</div><div class="line">&#125;</div><div class="line">Foo.prototype.identify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">who</span>) </span>&#123;</div><div class="line">    Foo.call( <span class="keyword">this</span>, who );</div><div class="line">&#125;</div><div class="line">Bar.prototype = <span class="built_in">Object</span>.create( Foo.prototype );</div><div class="line">Bar.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert( <span class="string">"Hello, "</span> + <span class="keyword">this</span>.identify() + <span class="string">"."</span> );</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> Bar( <span class="string">"b1"</span> );</div><div class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> Bar( <span class="string">"b2"</span> );</div><div class="line">b1.speak();</div><div class="line">b2.speak();</div></pre></td></tr></table></figure></p>
<p>对象关联风格实现功能完全相同的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Foo = &#123;</div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params">who</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.me = who;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">identify</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Bar = <span class="built_in">Object</span>.create( Foo );</div><div class="line">Bar.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert( <span class="string">"Hello, "</span> + <span class="keyword">this</span>.identify() + <span class="string">"."</span> );</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> b1 = <span class="built_in">Object</span>.create( Bar );</div><div class="line">b1.init( <span class="string">"b1"</span> );</div><div class="line"><span class="keyword">var</span> b2 = <span class="built_in">Object</span>.create( Bar );</div><div class="line">b2.init( <span class="string">"b2"</span> );</div><div class="line">b1.speak();</div><div class="line">b2.speak();</div></pre></td></tr></table></figure></p>
<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>ES5实现类风格的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Widget</span>(<span class="params">width,height</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.width = width || <span class="number">50</span>;</div><div class="line">    <span class="keyword">this</span>.height = height || <span class="number">50</span>;</div><div class="line">    <span class="keyword">this</span>.$elem = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line">Widget.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params">$where</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$elem) &#123;</div><div class="line">        <span class="keyword">this</span>.$elem.css( &#123;</div><div class="line">            <span class="attr">width</span>: <span class="keyword">this</span>.width + <span class="string">"px"</span>,</div><div class="line">            <span class="attr">height</span>: <span class="keyword">this</span>.height + <span class="string">"px"</span></div><div class="line">        &#125; ).appendTo( $where );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 子类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params">width,height,label</span>) </span>&#123;</div><div class="line">    <span class="comment">// 调用“super”构造函数</span></div><div class="line">    Widget.call( <span class="keyword">this</span>, width, height );</div><div class="line">    <span class="keyword">this</span>.label = label || <span class="string">"Default"</span>;</div><div class="line">    <span class="keyword">this</span>.$elem = $( <span class="string">"&lt;button&gt;"</span> ).text( <span class="keyword">this</span>.label );</div><div class="line">&#125;</div><div class="line"><span class="comment">// 让Button“继承”Widget</span></div><div class="line">Button.prototype = <span class="built_in">Object</span>.create( Widget.prototype );</div><div class="line"><span class="comment">// 重写render(..)</span></div><div class="line">Button.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params">$where</span>) </span>&#123;</div><div class="line">    <span class="comment">// “super”调用</span></div><div class="line">    Widget.prototype.render.call( <span class="keyword">this</span>, $where );</div><div class="line">    <span class="keyword">this</span>.$elem.click( <span class="keyword">this</span>.onClick.bind( <span class="keyword">this</span> ) );</div><div class="line">&#125;;</div><div class="line">Button.prototype.onClick = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Button '"</span> + <span class="keyword">this</span>.label + <span class="string">"' clicked!"</span> );</div><div class="line">&#125;;</div><div class="line">$( <span class="built_in">document</span> ).ready( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> $body = $( <span class="built_in">document</span>.body );</div><div class="line">    <span class="keyword">var</span> btn1 = <span class="keyword">new</span> Button( <span class="number">125</span>, <span class="number">30</span>, <span class="string">"Hello"</span> );</div><div class="line">    <span class="keyword">var</span> btn2 = <span class="keyword">new</span> Button( <span class="number">150</span>, <span class="number">40</span>, <span class="string">"World"</span> );</div><div class="line">    btn1.render( $body );</div><div class="line">    btn2.render( $body );</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>代码中丑陋的显式伪多态<code>Widget.call</code>和<code>Widget.prototype.render.call</code>。<br>使用ES6的class语法糖实现的功能相同的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(width,height) &#123;</div><div class="line">        <span class="keyword">this</span>.width = width || <span class="number">50</span>;</div><div class="line">        <span class="keyword">this</span>.height = height || <span class="number">50</span>;</div><div class="line">        <span class="keyword">this</span>.$elem = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    render($where)&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.$elem) &#123;</div><div class="line">            <span class="keyword">this</span>.$elem.css( &#123;</div><div class="line">                <span class="attr">width</span>: <span class="keyword">this</span>.width + <span class="string">"px"</span>,</div><div class="line">                <span class="attr">height</span>: <span class="keyword">this</span>.height + <span class="string">"px"</span></div><div class="line">            &#125; ).appendTo( $where );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(width,height,label) &#123;</div><div class="line">        <span class="keyword">super</span>( width, height );</div><div class="line">        <span class="keyword">this</span>.label = label || <span class="string">"Default"</span>;</div><div class="line">        <span class="keyword">this</span>.$elem = $( <span class="string">"&lt;button&gt;"</span> ).text( <span class="keyword">this</span>.label );</div><div class="line">    &#125;</div><div class="line">    render($where) &#123;</div><div class="line">        <span class="keyword">super</span>( $where );</div><div class="line">        <span class="keyword">this</span>.$elem.click( <span class="keyword">this</span>.onClick.bind( <span class="keyword">this</span> ) );</div><div class="line">    &#125;</div><div class="line">    onClick(evt) &#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Button '"</span> + <span class="keyword">this</span>.label + <span class="string">"' clicked!"</span> );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$( <span class="built_in">document</span> ).ready( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> $body = $( <span class="built_in">document</span>.body );</div><div class="line">    <span class="keyword">var</span> btn1 = <span class="keyword">new</span> Button( <span class="number">125</span>, <span class="number">30</span>, <span class="string">"Hello"</span> );</div><div class="line">    <span class="keyword">var</span> btn2 = <span class="keyword">new</span> Button( <span class="number">150</span>, <span class="number">40</span>, <span class="string">"World"</span> );</div><div class="line">    btn1.render( $body );</div><div class="line">    btn2.render( $body );</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>丑陋的语法都不见了，非常棒。<br>使用对象关联风格委托来实现功能相同的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Widget = &#123;</div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params">width,height</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.width = width || <span class="number">50</span>;</div><div class="line">        <span class="keyword">this</span>.height = height || <span class="number">50</span>;</div><div class="line">        <span class="keyword">this</span>.$elem = <span class="literal">null</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">insert</span>: <span class="function"><span class="keyword">function</span>(<span class="params">$where</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.$elem) &#123;</div><div class="line">            <span class="keyword">this</span>.$elem.css( &#123;</div><div class="line">                <span class="attr">width</span>: <span class="keyword">this</span>.width + <span class="string">"px"</span>,</div><div class="line">                <span class="attr">height</span>: <span class="keyword">this</span>.height + <span class="string">"px"</span></div><div class="line">            &#125; ).appendTo( $where );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> Button = <span class="built_in">Object</span>.create( Widget );</div><div class="line">Button.setup = <span class="function"><span class="keyword">function</span>(<span class="params">width,height,label</span>)</span>&#123;</div><div class="line">    <span class="comment">// 委托调用</span></div><div class="line">    <span class="keyword">this</span>.init( width, height );</div><div class="line">    <span class="keyword">this</span>.label = label || <span class="string">"Default"</span>;</div><div class="line">    <span class="keyword">this</span>.$elem = $( <span class="string">"&lt;button&gt;"</span> ).text( <span class="keyword">this</span>.label );</div><div class="line">&#125;;</div><div class="line">Button.build = <span class="function"><span class="keyword">function</span>(<span class="params">$where</span>) </span>&#123;</div><div class="line">    <span class="comment">// 委托调用</span></div><div class="line">    <span class="keyword">this</span>.insert( $where );</div><div class="line">    <span class="keyword">this</span>.$elem.click( <span class="keyword">this</span>.onClick.bind( <span class="keyword">this</span> ) );</div><div class="line">&#125;;</div><div class="line">Button.onClick = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Button '"</span> + <span class="keyword">this</span>.label + <span class="string">"' clicked!"</span> );</div><div class="line">&#125;;</div><div class="line">$( <span class="built_in">document</span> ).ready( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> $body = $( <span class="built_in">document</span>.body );</div><div class="line">    <span class="keyword">var</span> btn1 = <span class="built_in">Object</span>.create( Button );</div><div class="line">    btn1.setup( <span class="number">125</span>, <span class="number">30</span>, <span class="string">"Hello"</span> );</div><div class="line">    <span class="keyword">var</span> btn2 = <span class="built_in">Object</span>.create( Button );</div><div class="line">    btn2.setup( <span class="number">150</span>, <span class="number">40</span>, <span class="string">"World"</span> );</div><div class="line">    btn1.build( $body );</div><div class="line">    btn2.build( $body );</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>之前的一次调用变成了两次，需要初始化。这看似是个缺点，实则更好地支持关注分离原则，更灵活了。</p>
<h3 id="更好地语法"><a href="#更好地语法" class="headerlink" title="更好地语法"></a>更好地语法</h3><p>ES6的class语法可以简洁地定义类方法，ES6中也可以在任意对象的字面量形式中使用简洁方法声明，唯一的区别是对象的字面量形式仍然需要使用逗号来分隔元素，而class语法不需要。不过有一个小缺点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Foo = &#123;</div><div class="line">    bar() &#123; <span class="comment">/*..*/</span> &#125;,</div><div class="line">    <span class="attr">baz</span>: <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*..*/</span> &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>去掉语法糖之后的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Foo = &#123;</div><div class="line">    <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*..*/</span> &#125;,</div><div class="line">    <span class="attr">baz</span>: <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*..*/</span> &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>简洁形式的声明最终会变成一个匿名函数表达式，这样自我引用（递归、事件（解除）绑定、等等）更难。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>本章中我们看到了另一种更少见但是更强大的设计模式：行为委托。对象关联（对象之前互相关联）是一种编码风格，它倡导的是直接创建和关联对象，不把它们抽象成类。对象关联可以用基于原型的行为委托非常自然地实现。</p>
<h2 id="附录A-ES6中的Class"><a href="#附录A-ES6中的Class" class="headerlink" title="附录A ES6中的Class"></a>附录A ES6中的Class</h2><p>class语法很好的解决了一些典型原型风格代码中的许多显而易见的语法问题和缺点，但它毕竟不是新的类机制，只是现有原型机制的一种语法糖，自然有许多缺点没有解决或者新暴露了出来。</p>
<h3 id="class陷阱"><a href="#class陷阱" class="headerlink" title="class陷阱"></a>class陷阱</h3><p>class语法无法定义类成员属性（只能定义方法），这其实是把双刃剑，好处是原型链末端的“实例”不会意外地获取其他地方的属性（这些属性隐式被所有“实例”所共享），但缺点就是如果要跟踪“实例”之间的共享状态，且必须要这么做，就只能使用丑陋的<code>.prototype</code>语法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="comment">// 确保修改的是共享状态而不是在实例上创建一个屏蔽属性！</span></div><div class="line">        c.prototype.count++;</div><div class="line"></div><div class="line">        <span class="comment">// this.count 可以通过委托实现我们想要的功能</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Hello: "</span> + <span class="keyword">this</span>.count);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 直接向prototype对象上添加一个共享状态</span></div><div class="line">C.prototype.count = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> C(); <span class="comment">// Hello: 1</span></div><div class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> C(); <span class="comment">// Hello: 2</span></div><div class="line"></div><div class="line">c1.count === <span class="number">2</span>; <span class="comment">// true</span></div><div class="line">c1.count === c2.count; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>这个方法最大的问题就是违背了class语法的本意，在实现中暴露了<code>.prototype</code>。<br>此外，class语法仍勉励意外屏蔽的问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(id) &#123;</div><div class="line">        <span class="comment">// 噢，郁闷，我们的id 属性屏蔽了id() 方法</span></div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line">    id() &#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Id: "</span> + id );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> C( <span class="string">"c1"</span> );</div><div class="line">c1.id(); <span class="comment">// TypeError -- c1.id 现在是字符串"c1"</span></div></pre></td></tr></table></figure></p>
<p>除此之外，super也存在一些细微的问题，处于性能考虑，super并不是动态绑定的，它会在声明时“静态”绑定。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</div><div class="line">    foo() &#123; <span class="built_in">console</span>.log( <span class="string">"P.foo"</span> ); &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">P</span> </span>&#123;</div><div class="line">    foo() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> C();</div><div class="line">c1.foo(); <span class="comment">// "P.foo"</span></div><div class="line"><span class="keyword">var</span> D = &#123;</div><div class="line">    <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">"D.foo"</span> ); &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> E = &#123;</div><div class="line">    <span class="attr">foo</span>: C.prototype.foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 把E 委托到D</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf( E, D );</div><div class="line">E.foo(); <span class="comment">// "P.foo"</span></div></pre></td></tr></table></figure></p>
<p>大家可能期望super()会自动识别出E委托了D，所以E.foo()中的super()应该调用D.foo()，但实际并不是这样！这里只能手动修改super绑定：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> D = &#123;</div><div class="line">    <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">"D.foo"</span> ); &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 把E 委托到 D</span></div><div class="line"><span class="keyword">var</span> E = <span class="built_in">Object</span>.create( D );</div><div class="line"><span class="comment">// 手动把foo 的[[HomeObject]] 绑定到E，E.[[Prototype]] 是D， 所以 super() 是D.foo()</span></div><div class="line">E.foo = C.prototype.foo.toMethod( E, <span class="string">"foo"</span> );</div><div class="line">E.foo(); <span class="comment">// "D.foo"</span></div></pre></td></tr></table></figure></p>
<p>toMethod(..) 会复制方法并把homeObject 当作第一个参数（也就是我们传入的E），第二个参数（可选）是新方法的名称（默认是原方法名）。</p>
<hr>
<p>以上总结的知识要点只是现阶段我认为对我价值最大的部分，我略去了其中相当篇幅的我不感兴趣的还有暂时对我用处不大的部分，做这个总结不是为了将原书抛掉，只是想更精炼的提纯，提纯过程中对知识的再吸收，组织化。也方便之后的复习，提取。原书则退居到了字典的地位，时不时的翻翻目录，找找线索，待意外需要时取用便可以了。</p>

    
  </div>
</article>

</div>





  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
